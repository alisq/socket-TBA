<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MyApp</title>
  

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">

  <link rel="stylesheet" href="css/styles.css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-scrollTo/2.1.2/jquery.scrollTo.min.js"></script>

    <script src="js/p5.min.js"></script>
    <script src="js/p5.collide2d.min.js"></script>
        


        
</head>
<body>

            <script>
    
//var socket = io();
  
var city = [];
var trunks = [];
var branches = [];
var sturgeon = [];
var mountain;
var territory;
var flock;
var pond;

var pondLeak = false;

var FPS = 60;

var treeLimit = 30;
var branchLimit = 180; //should be tree Limit * tree.branchAllow
var treeTemp = 5 * FPS; //in seconds



function setup() {
    var windowWidth = $(window).width();
    var windowHeight = $(window).height();
    //textFont(myFont);
    createCanvas(windowWidth, windowHeight);
    
    territory = new Territory();
    territory.start();
    
    mountain = new Mountain();
    mountain.start();
    
    city = new City()
    
    pond = new Pond();
    pond.start();
    
    for (var i=0; i < 1; i++){
        sturgeon.push(new Sturgeon());
    };
    
    for (var i=0; i < 1; i++) {
        trunks.push(new Trunk());
    }
    
    flock = new Flock();
    
    for (var i = 0; i < 4; i++) {
        flock.addBoid();
    }
}

function draw() {
    background(0);
    
    mountain.display();
    mountain.decay();
    
    territory.display();
    territory.update();
    
    flock.run();
    
    city.display();
    city.grow();
    
    pond.display();
    
    for (var i=0; i < sturgeon.length; i++){
        sturgeon[i].display();
        sturgeon[i].move();
        sturgeon[i].checkCollision();
    }
    
    for (var i=0; i<trunks.length; i++){
        trunks[i].display();
        trunks[i].grow();
        trunks[i].checkCollision(i);
    };
    
    for (var i=0; i<branches.length; i++){
        branches[i].display();
        branches[i].grow();
        branches[i].checkCollision(i);
    }
    
    if (frameCount % treeTemp == 0){ //keep automaitcally growing trees
        if (trunks.length < treeLimit){
            trunks.push(new Trunk());
        };
    };
    
    if (pondLeak == true){
        pond.leak();
        pond.checkCollision();
    };
    
    if (flock.boids.length < 4){ 
        flock.addBoid();
    };
    fill(255, 255, 255);
//    blendMode(DIFFERENCE);
//    t = "TREE\nTEMPORALITY\n\nmulti-species research on time, territory and public art practice\n\nOCADU UNIVERSITY\nNovember 25th, 2017";
//    textSize(30);
//    text(t, 30, 30, 500,500);
    blendMode(BLEND);
    
}

function mouseClicked(){
    sturgeon[0].death();
}

function Trunk() {
    this.x = random(width);
    this.y = random(100, height);
    this.w = 4;
    this.h = 4;
    this.pixelArray = [];
//    this.growLimit = 20; //BACKUP
    this.growLimit = cam2;
    this.stopGrowth = false;
    
    this.branchAllow = 6;
    
//    this.temp = 1 * FPS //BACKUP
    this.temp = cam1; //in frames
    
    this.display = function() {
        for (var i=0; i < this.pixelArray.length; i++) {
            fill(255);
            noStroke();
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function() {
        if (frameCount % this.temp == 0){
            if (this.stopGrowth == false){
                if (this.pixelArray.length < this.growLimit){
                    this.y -= 4;
                    this.x += random(-2, 2);
                    this.pixelArray.push([this.x, this.y, this.w, this.h]);
                } else if (this.pixelArray.length == this.growLimit){
                    this.branchAllow = this.branchAllow - 2;
                    branches.push(new Branch(this.x, this.y, 'left', this.branchAllow/2));
                    branches.push(new Branch(this.x, this.y, 'right', this.branchAllow/2)); 
                    this.stopGrowth = true;
                    console.log('2 New Branches: ' + branches.length + ' branches on screen');
                };
            };
        };
    }
    
    this.checkCollision = function(trunkIndex){
        //figure out location of sturgeon's mouth
        if (sturgeon[0].xDir == 'left'){
            var sturMouthX = sturgeon[0].x;
            var sturMouthY = sturgeon[0].y;
        } else if (sturgeon[0].xDir == 'right'){
            var sturMouthX = sturgeon[0].x + 24 + (12 * (sturgeon[0].body + 1));
            var sturMouthY = sturgeon[0].y;
        };
        
        for (var i=this.pixelArray.length-1; i >=0; i--){ //for each pixel in trunk
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(sturMouthX, sturMouthY, sturgeon[0].w, sturgeon[0].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collision){
                this.death(trunkIndex);
                sturgeon[0].grow();
                break;
            };
        };
        
        branchTrunk:
        for (var i=this.pixelArray.length - 1; i >= 0; i--){// for each pixel in trunk
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].w, flock.boids[k].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    this.death(trunkIndex);
                    flock.grow();
                    break branchTrunk;
                };
            };
        };
    }
    
    this.death = function(trunkIndex){
        trunks.splice(trunkIndex, 1); //remove this tree from array
        if (trunks.length < treeLimit){ ///grow another tree if trees are less than treeLimit
            trunks.push(new Trunk());
            console.log('New Tree: ' + trunks.length + ' live trees on screen');
        };
    }
}

function Branch(x, y, d, b) {
    this.x = x;
    this.y = y;
    this.w = 4;
    this.h = 4;
    
    this.branchAllow = b;
    
//    this.temp = 1 * FPS; //BACKUP in seconds
    this.temp = cam1; //in frames

    this.yArray = [2,4];
    this.yRand = this.yArray[round(random(1))];
    this.d = d;
    
    this.pixelArray = [];
//    this.growLimit = 20; //BACKUP
    this.growLimit = cam2;
    this.stopGrowth = false;
    
    this.display = function(){
        for (var i=0; i < this.pixelArray.length; i++) {
            fill(255);
            noStroke();
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function(){
        if (frameCount % this.temp == 0){
            if (this.stopGrowth == false){
                if (this.pixelArray.length < this.growLimit){
                    if (this.d == 'left'){
                        this.y -= this.yRand;
                        this.x += random(-4, 0);
                        this.pixelArray.push([this.x, this.y, this.w, this.h]);
                    } else if (this.d == 'right'){
                        this.y -= this.yRand;
                        this.x += random(0, 4);
                        this.pixelArray.push([this.x, this.y, this.w, this.h]);
                    };
                } else if (this.pixelArray.length == this.growLimit){
                    this.stopGrowth = true;
                    if (branches.length < branchLimit){ //if more branches are allowed on page
                        if (this.branchAllow > 0){ //if more branches are allowed on tree
                            this.branchAllow = this.branchAllow - 2;
                            branches.push(new Branch(this.x, this.y, 'left', this.branchAllow/2)); 
                            branches.push(new Branch(this.x, this.y, 'right', this.branchAllow/2));
                            console.log('2 New Branches: ' + branches.length + ' branches on screen');
                        };
                    }
                };
            };
        };
    }
    
    this.checkCollision = function(branchIndex){
        //figure out location of sturgeon's mouth
        if (sturgeon[0].xDir == 'left'){
            var sturMouthX = sturgeon[0].x;
            var sturMouthY = sturgeon[0].y;
        } else if (sturgeon[0].xDir == 'right'){
            var sturMouthX = sturgeon[0].x + 24 + (12 * (sturgeon[0].body + 1));
            var sturMouthY = sturgeon[0].y;
        };
        
        for (var i=this.pixelArray.length - 1; i >= 0; i--) { //for each pixel in branch 
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(sturMouthX, sturMouthY, sturgeon[0].w, sturgeon[0].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collision){
                this.death(branchIndex);
                sturgeon[0].grow();
                break;
            };
        };
        
        branchKokanee:
        for (var i=this.pixelArray.length - 1; i >=0; i--){// for each pixel in branch
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].w, flock.boids[k].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    this.death(branchIndex);
                    flock.grow();
                    break branchKokanee;
                };
            };
        };

    }
    
    this.death = function(branchIndex){
        branches.splice(branchIndex, 1); //remove this branch from array
    }
}

function City() {
    this.x = random(width);
    this.y = random(height);
    this.w = 2;
    this.h = 2;
    
    this.xyArray = [-2, 2];
    this.pixelArray = [];
    
    this.temp = 0.05 * FPS; //in seconds
    
    this.display = function() {
        for (var i=0; i < this.pixelArray.length; i ++){
            fill(255);
            stroke(255);
            strokeWeight(2);
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function() {
        if (frameCount % this.temp == 0){
            var xRand = this.xyArray[round(random(1))];
            var yRand = this.xyArray[round(random(1))];

            this.x += xRand;
            this.y += yRand;
            var collisionDetected = this.checkCollision();

            if (collisionDetected == false){
                this.pixelArray.push([this.x, this.y, this.w, this.h]);
            };
        };
    }
    
    this.checkCollision = function() {
        var anyCollision = false;
        //check for collision with other city pixels
        for (var i=0; i < this.pixelArray.length; i ++){
            var collide = collideRectRect(this.x, this.y, this.w, this.h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };
        
        //check for collision with trunk
        for (var i=0; i < trunks.length; i++){// for each trunk
            for (var k=0; k < trunks[i].pixelArray.length; k++){// for each pixel of each trunk
                var collide = collideRectRect(this.x, this.y, this.w, this.h, trunks[i].pixelArray[k][0], trunks[i].pixelArray[k][1], trunks[i].pixelArray[k][2], trunks[i].pixelArray[k][3]);
                if (collide == true){
                    anyCollision = true;
                };
            };
        };
        
        //check for collision with branches
        for (var i=0; i < branches.length; i++){// for each branch
            for (var k=0; k < branches[i].pixelArray.length; k++){// for each pixel of each branch
                var collide = collideRectRect(this.x, this.y, this.w, this.h, branches[i].pixelArray[k][0], branches[i].pixelArray[k][1], branches[i].pixelArray[k][2], branches[i].pixelArray[k][3]);
                if (collide == true){
                    anyCollision = true;
                };
            };
        };
        
        //check for collision with mountain
        for (var i=0; i < mountain.pixelArray.length; i++){
            var collide = collideRectRect(this.x, this.y, this.w, this.h, mountain.pixelArray[i][0], mountain.pixelArray[i][1], mountain.pixelArray[i][2], mountain.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };
        
        //check for collision with pond
        for (var i=0; i < pond.pixelArray.length; i++){ //for each pixel of pond
            var collide = collideRectRect(this.x, this.y, this.w, this.h, pond.pixelArray[i][0], pond.pixelArray[i][1], pond.pixelArray[i][2], pond.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };

        //check for collision with bounds
        if (this.x < 0 || this.y < 0 || this.x > (width - this.w) || this.y > (height - this.h)){
            anyCollision = true;
        };
        
        return anyCollision;
    }
}

function Sturgeon() {
    this.x = random(width);
    this.y = random(height);
    this.w = 4;
    this.h = 4;
    
    this.xDir = 'right';
    this.xMoveArray = [50, 100, 200, 300, 400];
    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
    this.xMoveCount = 0;
    
    this.yDir = 'up';
    this.yMoveArray = [10, 20, 30, 40, 50, 60, 70, 80];
    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
    this.yMoveCount = 0;
    
    this.fishTop;
    this.fishLeft;
    this.fishRight;
    this.fishBottom;
    
    this.feed = 0;
    this.maxFeed = 10;
    this.body = 0;
    this.bodyMax = 12;
    
    this.display = function(){
        fill(255);
        noStroke();
        
        if (this.xDir == 'left'){
            //head
            rect(this.x, this.y, this.w, this.h);

            rect(this.x + 4, this.y - 4, this.w, this.h);
            rect(this.x + 4, this.y + 4, this.w, this.h);

            rect(this.x + 8, this.y - 8, this.w, this.h);
            rect(this.x + 8, this.y - 4, this.w, this.h);
            rect(this.x + 8, this.y, this.w, this.h);
            rect(this.x + 8, this.y + 4, this.w, this.h);
            rect(this.x + 8, this.y + 8, this.w, this.h);

            rect(this.x + 12, this.y - 4, this.w, this.h);
            rect(this.x + 12, this.y, this.w, this.h);
            rect(this.x + 12, this.y + 4, this.w, this.h);

            rect(this.x + 16, this.y, this.w, this.h);

            //body
            for (var i=0; i <= this.body; i++){
                var mult = 20 + (12 * i);
                var bodyY = this.y;

                rect(this.x + mult, bodyY - 8, this.w, this.h);
                rect(this.x + mult, bodyY - 4, this.w, this.h);
                rect(this.x + mult, bodyY + 4, this.w, this.h);
                rect(this.x + mult, bodyY + 8, this.w, this.h);

                rect(this.x + mult + 4, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 4, bodyY, this.w, this.h);
                rect(this.x + mult + 4, bodyY + 4, this.w, this.h);

                rect(this.x + mult + 8, bodyY, this.w, this.h);
            };

            //tail
            var tailX = 20 + (12 * (this.body + 1));

            rect(this.x + tailX, this.y - 4, this.w, this.h);
            rect(this.x + tailX, this.y, this.w, this.h);
            rect(this.x + tailX, this.y + 4, this.w, this.h);

            rect(this.x + tailX + 4, this.y - 8, this.w, this.h);
            rect(this.x + tailX + 4, this.y - 4, this.w, this.h);
            rect(this.x + tailX + 4, this.y + 4, this.w, this.h);
            rect(this.x + tailX + 4, this.y + 8, this.w, this.h);
            
        } else if (this.xDir == 'right'){
            
            //tail
            rect(this.x, this.y - 8, this.w, this.h);
            rect(this.x, this.y - 4, this.w, this.h);
            rect(this.x , this.y + 4, this.w, this.h);
            rect(this.x, this.y + 8, this.w, this.h);

            rect(this.x + 4, this.y - 4, this.w, this.h);
            rect(this.x + 4, this.y, this.w, this.h);
            rect(this.x + 4, this.y + 4, this.w, this.h);

            //body
            for (var i=0; i <= this.body; i++){
                var mult = 8 + (12 * i);
                var bodyY = this.y;
                
                rect(this.x + mult, bodyY, this.w, this.h);
                
                rect(this.x + mult + 4, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 4, bodyY, this.w, this.h);
                rect(this.x + mult + 4, bodyY + 4, this.w, this.h);

                rect(this.x + mult + 8, bodyY - 8, this.w, this.h);
                rect(this.x + mult + 8, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 8, bodyY + 4, this.w, this.h);
                rect(this.x + mult + 8, bodyY + 8, this.w, this.h);
            };
            
            //head
            var HeadX = 8 + (12 * (this.body + 1));
            
            rect(this.x + HeadX, this.y, this.w, this.h);

            rect(this.x + HeadX + 4, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 4, this.y, this.w, this.h);
            rect(this.x + HeadX + 4, this.y + 4, this.w, this.h);

            rect(this.x + HeadX + 8, this.y - 8, this.w, this.h);
            rect(this.x + HeadX + 8, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 8, this.y, this.w, this.h);
            rect(this.x + HeadX + 8, this.y + 4, this.w, this.h);
            rect(this.x + HeadX + 8, this.y + 8, this.w, this.h);

            rect(this.x + HeadX + 12, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 12, this.y + 4, this.w, this.h);

            rect(this.x + HeadX + 16, this.y, this.w, this.h);
        };
    }
    
    this.grow = function(){
        this.feed++;
        console.log('Sturgeon has eaten ' + this.feed + ' branches');
        if (this.feed % this.maxFeed == 0){
            this.body++;
            console.log('Sturgeon has grown to size ' + this.body);
        };
        if (this.body == this.bodyMax){
            this.death();
            console.log('Sturgeon has died');
        };
    }
    
    this.move = function(){ 
        // DETERMINE FISH DIMENSIONS
        this.fishTop = this.y - 12;
        this.fishLeft = this.x;
        this.fishRight = this.x + 20 + 8 + (12 * (this.body + 1));
        this.fishBottom = this.y + 12;
        
        if (this.fishTop < 0){ //if fish hits top of frame, move down
            this.yDir = 'down'
            this.yMoveCount = 0;
            this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
        } else if (this.fishLeft < 0){ //if fish hits left edge of frame, move right
            this.xDir = 'right'
            this.xMoveCount = 0;
            this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
        } else if (this.fishRight > windowWidth){ //if fish hits right edge, move left
            this.xDir = 'left'
            this.xMoveCount = 0;
            this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
        } else if (this.fishBottom > windowHeight){ //if fish hits bottom, move up
            this.yDir = 'up'
            this.yMoveCount = 0;
            this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
        };
        
        // DETERMINE LEFT OR RIGHT
        if (this.xMoveCount == this.xMove){
            if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                this.xDir = 'left'
                this.xMoveCount = 0;
                this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
            } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                this.xDir = 'right'
                this.xMoveCount = 0;
                this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
            };
        };
        
        // MOVE LEFT OR RIGHT 
        if (this.xDir == 'left'){
            this.x--;
            this.xMoveCount++;
        } else if (this.xDir == 'right'){
            this.x++;
            this.xMoveCount++;
        };
        
        // DETERMINE UP OR DOWN
        if (this.yMoveCount == this.yMove){ //if fish yMoveCount is equal to yMove
            if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                this.yDir = 'down'
                this.yMoveCount = 0;
                this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
            } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                this.yDir = 'up'
                this.yMoveCount = 0;
                this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
            };
        };
        
        // MOVE UP OR DOWN
        if (this.yDir == 'up'){ //if fish direction is up, go up
            this.y--;
            this.yMoveCount++;
        } else if (this.yDir == 'down'){ //if fish direction is down, go down
            this.y++;
            this.yMoveCount++;
        };
    }
    
    this.checkCollision = function(){
        //figure out location of sturgeon's mouth
        var fishX = this.x;
        var fishY = this.y;
        var fishW = 28 + (12 * (this.body + 1));
        var fishH = 20;
        
        // check for collision with city
        for (var i=0; i < city.pixelArray.length; i++){ //for each pixel in city
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(fishX, fishY, fishW, fishH, city.pixelArray[i][0], city.pixelArray[i][1], city.pixelArray[i][2], city.pixelArray[i][3]);
            
            if (collision){ //if collision with city, change direction
                console.log('Sturgeon Collision with City');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+=4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        };
        
        // check for collision with mountain
        for (var i=0; i < mountain.pixelArray.length; i++){ //for each pixel in mountain
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(fishX, fishY, fishW, fishH, mountain.pixelArray[i][0], mountain.pixelArray[i][1], mountain.pixelArray[i][2], mountain.pixelArray[i][3]);
            if (collision){ //if collision with mountain, change direction
                console.log('Sturgeon Collision with Mountain');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+= 4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        };
        
        if (pondLeak == false){ //if pond has not leaked
            var pondWidth = pond.w*pond.pondWidth;
            var pondHeight = pond.h*pond.pondHeight

            var collision = collideRectRect(fishX, fishY, fishW, fishH, pond.x - pondWidth, pond.y, pondWidth, pondHeight);
            if (collision){ //if collision with mountain, change direction
                console.log('Sturgeon Collision with Tailings Pond');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+= 4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        } else if (pondLeak == true){
            for (var i=0; i < pond.pixelArray.length; i++){ //for each pixel of pond
                var collide = collideRectRect(fishX, fishY, fishW, fishH, pond.pixelArray[i][0], pond.pixelArray[i][1], pond.pixelArray[i][2], pond.pixelArray[i][3]);
                if (collide){
                    this.death();
                    console.log('Sturgeon killed by Tailing Pond leak');
                    break;
                }
            };
        };
    }
    
    this.death = function() {
        sturgeon.splice(0, 1);
        sturgeon.push(new Sturgeon);
        console.log('Sturgeon is born');
    }
}

function Mountain(){
    this.pixelArray = [];
    this.minedArray = [];
    
    this.height = 20;
    this.left = 24 + (this.height * 4);
    this.mountainWidth = 52 + (this.height * 8);
    this.mountainHeight = 20 + (this.height * 4);
    
    this.x = random(this.left, territory.x);
    this.y = random(height - this.mountainHeight);
    this.w = 4;
    this.h = 4;
    
    this.temp = 15 * FPS; //in seconds

    /// MOUNTAIN HEIGHT ///

    this.start = function(){
        for (var i=0; i <= this.height; i++){
            var mountY = 16 + (i * 4);
            var mountXPixels = 13 + (i * 2)
            for (var k=0; k <= floor(mountXPixels/2); k++){
                var mountX = k * 4;
                this.pixelArray.push([this.x + mountX, this.y + mountY, this.w, this.h]);
            };
            for (var k=1; k <= floor(mountXPixels/2); k++){
                var mountX = k * -4;
                this.pixelArray.push([this.x + mountX, this.y + mountY, this.w, this.h]);
            };
        };
    }
    
    this.display = function(){
        fill(255);
        noStroke();
        
        /// MOUNTAIN TOP ///
        rect(this.x - 8, this.y, this.w, this.h);
        rect(this.x - 4, this.y, this.w, this.h);
        rect(this.x, this.y, this.w, this.h);
        rect(this.x + 4, this.y, this.w, this.h);
        rect(this.x + 8, this.y, this.w, this.h);

        rect(this.x - 12, this.y + 4, this.w, this.h);
        rect(this.x + 12, this.y + 4, this.w, this.h);

        rect(this.x - 16, this.y + 8, this.w, this.h);
        rect(this.x + 16, this.y + 8, this.w, this.h);

        rect(this.x - 20, this.y + 12, this.w, this.h);
        rect(this.x - 16, this.y + 12, this.w, this.h);
        rect(this.x - 12, this.y + 12, this.w, this.h);
        rect(this.x + 12, this.y + 12, this.w, this.h);
        rect(this.x + 16, this.y + 12, this.w, this.h);
        rect(this.x + 20, this.y + 12, this.w, this.h);

        rect(this.x - 20, this.y + 12, this.w, this.h);
        rect(this.x - 16, this.y + 12, this.w, this.h);
        rect(this.x - 12, this.y + 12, this.w, this.h);
        rect(this.x + 12, this.y + 12, this.w, this.h);
        rect(this.x + 16, this.y + 12, this.w, this.h);
        rect(this.x + 20, this.y + 12, this.w, this.h);
        
        for (var i=0; i < this.pixelArray.length; i ++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
        
        for (var i=0; i < this.minedArray.length; i ++){
            rect(this.minedArray[i][0], this.minedArray[i][1], this.minedArray[i][2], this.minedArray[i][3]);
        };
    }
    
    this.decay = function(pixelArray){
        if (frameCount % this.temp == 0){
            if (this.pixelArray.length > 0){
                var pixelIndex = floor(random(this.pixelArray.length));
                this.pixelArray.splice(pixelIndex, 1);

                this.minedArray.push([random(territory.x), random(height), this.w, this.h]);
                console.log('1 Obsidian Mined: ' + this.pixelArray.length + ' Obsidain left in Mountain');
            };
        };
    }
}

function Territory(){
    this.x = width/3;
    this.y = 0;
    this.w = 4;
    this.h = 4;
    
    this.height = height/12;
    this.xArray = [-4, 0, 4];
    this.xRand = this.xArray[round(random(2))];
    this.temp = 1 * FPS //in seconds
    
    this.xUpdateArray = [-1, 0, 1];
    
    this.pixelArray = [];
    
    this.start = function(){
        for (var i=0; i <= this.height; i++){
            this.pixelArray.push([this.x, this.y, this.w, this.h]);
            
            this.y+=12;
            this.xRand = this.xArray[round(random(2))];
            this.x += this.xRand;
        };
    }
    
    this.display = function(){
        noStroke();
        fill(255);
        for (var i=0; i < this.pixelArray.length; i++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.update = function(){
        if (frameCount % this.temp == 0){
            this.x = width/3;
            this.y = 0;
            
            for (var i=0; i < this.pixelArray.length; i++){
                this.xRand = this.xUpdateArray[round(random(2))];
                this.pixelArray[i][0]+=this.xRand;
            };
        };
    }
}

function Pond(){
    this.pondWidth = 30;
    this.pondHeight = 20;
    
    this.w = 4;
    this.h = 4;
    
    this.x = random(width - (this.w*this.pondWidth));
    this.y = random(height - (this.h*this.pondHeight));
    this.yUpdate = 0;
    
    this.randArray = [-4, 0, 4];
    this.pixelArray = [];
    
    this.leakCount = 0;
    this.leakMax = 7200; // 
    this.newPondTime = 60000; //in ms
    
    this.start = function(){
        for (var i=0; i < this.pondWidth; i++){
            for (var k=0; k < this.pondHeight; k++){
                this.pixelArray.push([this.x, this.y + this.yUpdate, this.w, this.h]);
                this.yUpdate = this.yUpdate + 4;
            };
            this.yUpdate = 0;
            this.x = this.x + 4;
        };
    }
    
    this.display = function(){
        fill(255);
        noStroke();
        for (var i=0; i < this.pixelArray.length; i++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.leak = function(){
        this.leakCount++;
        if (this.leakCount < this.leakMax){
            for (var i=0; i < this.pixelArray.length; i++){
                var xRand = this.randArray[round(random(2))];
                var yRand = this.randArray[round(random(2))];
                this.pixelArray[i][0] = this.pixelArray[i][0] + xRand;
                this.pixelArray[i][1] = this.pixelArray[i][1] + yRand;
            };
        } else { //if leakMax is reached, reset pond
            this.pixelArray = [];
            this.leakCount = 0;
            pondLeak = false;
            this.x = random(width - (this.w*this.pondWidth));
            this.y = random(height - (this.h*this.pondHeight));
            setTimeout(function(){pond.start();}, this.newPondTime);
        };
    }
    
    this.checkCollision = function(){
        // check collision with trees
        for (var i=0; i < this.pixelArray.length; i++){//for each pixel in array
            for (var k=trunks.length-1; k >=0; k--){// for each trunk
                for (var m=0; m < trunks[k].pixelArray.length; m++){// for each pixel
                    var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], trunks[k].pixelArray[m][0], trunks[k].pixelArray[m][1], trunks[k].pixelArray[m][2], trunks[k].pixelArray[m][3]);
                    if (collision){
                        trunks[k].death(k);
                        break;
                    };
                };
            };
        };
        
        // check collision with branches
        for (var i=0; i < this.pixelArray.length; i++){//for each pixel in array
            for (var k=branches.length-1; k >=0; k--){// for each tree
                for (var m=0; m < branches[k].pixelArray.length; m++){// for each pixel of each tree
                    var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], branches[k].pixelArray[m][0], branches[k].pixelArray[m][1], branches[k].pixelArray[m][2], branches[k].pixelArray[m][3]);
                    if (collision){
                        branches[k].death(k);
                        break;
                    }
                };
            };
        };
        
        //check collision with city
        for (var i=this.pixelArray.length-1; i >=0 ; i--){//for each pixel in array
            for (var k=city.pixelArray.length-1; k>=0; k--){// for each pixel in city
                var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], city.pixelArray[k][0], city.pixelArray[k][1], city.pixelArray[k][3], city.pixelArray[k][1]);
                if (collision){
                    this.pixelArray.splice(i, 1);//remove pond pixel
                    city.pixelArray.splice(k, 1);//remove city pixel
                    break;
                };
            };
        };
        
        //check collision with kokanee
        for (var i=this.pixelArray.length-1; i >=0 ; i--){//for each pixel in array
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].h, flock.boids[k].w, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    flock.death();
                    console.log('Kokanee killed by Toxic Waste');
                };
            };
        };
    }
}

function Flock() {
    this.boids = [];
    this.feed = 0;
    this.maxFeed = 20;
    this.maxBoids = 30;
    
    this.run = function() {
        for (var i = 0; i < this.boids.length; i++) {
            this.boids[i].run(this.boids);  // Passing the entire list of boids to each boid individually
        };
    }
    
    this.addBoid = function() {
        this.boids.push(new Boid(random(width), random(height)));
        console.log('1 New Kokanee: ' + this.boids.length + ' Kokanee on screen');
    }
    
    this.grow = function(){
        this.feed++;
        console.log('Kokanee have eaten ' + this.feed + ' branches');
        if (this.feed % this.maxFeed == 0){
            this.addBoid();
        };
        if (this.boids.length == this.maxBoids){
            this.death();
        };
    }
    
    this.death = function(){
        this.boids.splice(0, 1);
        console.log('A Kokanee has died');
    }
}

function Boid(x,y) {
    this.acceleration = createVector(0,0);
    this.velocity = createVector(random(-1,1),random(-1,1));
    this.position = createVector(x,y);
    this.r = 3.0;
    this.maxspeed = 3;    // Maximum speed
    this.maxforce = 0.05; // Maximum steering force
    this.w = 8;
    this.h = 4;
    
    this.run = function(boids) {
        this.flock(boids);
        this.update();
        this.borders();
        this.render();
    }
    
    this.applyForce = function(force) {
        // We could add mass here if we want A = F / M
        this.acceleration.add(force);
    }
    
    // We accumulate a new acceleration each time based on three rules
    this.flock = function(boids) {
        var sep = this.separate(boids);   // Separation
        var ali = this.align(boids);      // Alignment
        var coh = this.cohesion(boids);   // Cohesion
        // Arbitrarily weight these forces
        sep.mult(1.5);
        ali.mult(1.0);
        coh.mult(1.0);
        // Add the force vectors to acceleration
        this.applyForce(sep);
        this.applyForce(ali);
        this.applyForce(coh);
    }
    
    // Method to update location
    this.update = function() {
        // Update velocity
        this.velocity.add(this.acceleration);
        // Limit speed
        this.velocity.limit(this.maxspeed);
        this.position.add(this.velocity);
        // Reset accelertion to 0 each cycle
        this.acceleration.mult(0);
    }
    
    // A method that calculates and applies a steering force towards a target
    // STEER = DESIRED MINUS VELOCITY
    this.seek = function(target) {
        var desired = p5.Vector.sub(target,this.position);  // A vector pointing from the location to the target
        // Normalize desired and scale to maximum speed
        desired.normalize();
        desired.mult(this.maxspeed);
        // Steering = Desired minus Velocity
        var steer = p5.Vector.sub(desired,this.velocity);
        steer.limit(this.maxforce);  // Limit to maximum steering force
        return steer;
    }
    
    this.render = function() {
        noStroke();
        fill(255);
        rect(this.position.x, this.position.y, this.w, this.h);
    }
    
    // Wraparound
    this.borders = function() {
      if (this.position.x < -this.r)  this.position.x = width +this.r;
      if (this.position.y < -this.r)  this.position.y = height+this.r;
      if (this.position.x > width +this.r) this.position.x = -this.r;
      if (this.position.y > height+this.r) this.position.y = -this.r;
    }
    
    // Separation
    // Method checks for nearby boids and steers away
    this.separate = function(boids) {
      var desiredseparation = 12.0;
      var steer = createVector(0,0);
      var count = 0;
      // For every boid in the system, check if it's too close
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
        if ((d > 0) && (d < desiredseparation)) {
          // Calculate vector pointing away from neighbor
          var diff = p5.Vector.sub(this.position,boids[i].position);
          diff.normalize();
          diff.div(d);        // Weight by distance
          steer.add(diff);
          count++;            // Keep track of how many
        }
      }
      // Average -- divide by how many
      if (count > 0) {
        steer.div(count);
      }

      // As long as the vector is greater than 0
      if (steer.mag() > 0) {
        // Implement Reynolds: Steering = Desired - Velocity
        steer.normalize();
        steer.mult(this.maxspeed);
        steer.sub(this.velocity);
        steer.limit(this.maxforce);
      }
      return steer;
    }
    
    // Alignment
    // For every nearby boid in the system, calculate the average velocity
    this.align = function(boids) {
      var neighbordist = 50;
      var sum = createVector(0,0);
      var count = 0;
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        if ((d > 0) && (d < neighbordist)) {
          sum.add(boids[i].velocity);
          count++;
        }
      }
      if (count > 0) {
        sum.div(count);
        sum.normalize();
        sum.mult(this.maxspeed);
        var steer = p5.Vector.sub(sum,this.velocity);
        steer.limit(this.maxforce);
        return steer;
      } else {
        return createVector(0,0);
      }
    }
    
    // Cohesion
    // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
    this.cohesion = function(boids) {
      var neighbordist = 50;
      var sum = createVector(0,0);   // Start with empty vector to accumulate all locations
      var count = 0;
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        if ((d > 0) && (d < neighbordist)) {
          sum.add(boids[i].position); // Add location
          count++;
        }
      }
      if (count > 0) {
        sum.div(count);
        return this.seek(sum);  // Steer towards the location
      } else {
        return createVector(0,0);
      }
    }
}
            
var cam1 = 60;
var cam2 = 10;

/////WEBSOCKET INFLUENCES:
//
//    //WHEN YOU BREACH THE TAILINGS POND
//    socket.on('breach-out', function(data){
//        if (pondLeak == false) {
//            pondLeak = true;        
//        }
//    });
//
//    //WHEN A BOOK GETS PRINTED
//    socket.on('printed-out', function(data){
//        var r = floor(random(trunks.length));
//        trunks[r].death(r);
//    });
//
//  //UPDATED WEATHER DATA FROM MANILLA EVERY THIRTY SECONDS
//    socket.on('manila-out', function(data) { 
//        console.log(data);
//       //do someting with the "data" variable.
//       //have a look at all the info we have in that JSON feed here: http://openweathermap.org/current#parameter
//
//    });
//
//    //THE CAMERAS
//    socket.on('c2-out', function(data) { 
//        var newCam1 = data[0]; //cam 1 determines tree growth rate
//        newCam1 = (newCam1[0] + newCam1[1] + newCam1[2])/3;
//        newCam1 = 120 * (newCam1/255);
//        newCam1 = 120 - newCam1;
//        cam1 = floor(newCam1);
//        console.log(cam1);
//        
//        newCam2 = data[1];
//        newCam2 = (newCam2[0] + newCam2[1] + newCam2[2])/3;
//        newCam2 = (newCam2-0)/(255-0)*(20-5)+5;
//        cam2 = floor(newCam2);
//        console.log(cam2);
//        //this is just receiving one pixel from each feed, you can change what gets sent from this page:
//
//        // /public/camera1.html
//    });
    </script>
    