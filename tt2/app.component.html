<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MyApp</title>
  

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">

  <link rel="stylesheet" href="css/styles.css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-scrollTo/2.1.2/jquery.scrollTo.min.js"></script>

    <script src="js/script.js"></script>
    <script src="js/p5.min.js"></script>
    <script src="js/p5.collide2d.min.js"></script>
        


        
</head>
<body>
        <div id=""></div>


    	<div id="menu">
	        <a class="tt"  id="menu-blank" href="#">TREE<BR />
            TEMPORALITY</a><br />
            multi-species research on time, territory and public art practice
	        <br /><br /><br />
	        <div class="menu" id="menu-project">The Project</div>
	        <div class="menu" id="menu-recommendation">Recommendations</div>
	        <div class="menu" id="menu-participants">Participants</div>
	        <div class="menu" id="menu-event">The Event</div>
	        
	        <div class="menu" id="menu-contact">Contact</div>
            <br />
            <div class="menu" id="menu-legend">Legend</div>
	    </div>


        <div id="container">
        	<div id="content">
                
                
                
                

                
                
                
            
    
<!--                <div *ngFor="let section of sections">-->
                <div class="section" id="blank"></div>
                <div class="section" id="project">
                    <div class="big-3">
                        Tree Temporality is an ambitious speculative project that explores more-than-human considerations of public art in our natural and urban environments. Through the tree and other intelligent entities, the project endeavours to acknowledge existing sentient relations and agencies, from soil and skin, to technology and synthetic-life, to animals and organisms, to law and territory. The project was initiated through a series of internal gatherings led by a group of artists and designers that presented their perspective on this topic and its critical role in their practice. The content and connections that emerged from these sessions shaped a performative public happening while allowing the event to function as another layer of the research and generating further content towards the project’s central questions:
 <br /><br />
If we reflect on the tree’s relation to time and territory, might it perform as precedent in how we regard resilience, permanence, ephemerality, legality and land within public art practice?<br /><br />
How does thinking through time of a tree (including its pasts and projected futures) address other temporalities that may exist?<br /><br />
How can we be attentive to the decolonial implications and possibilities of the research if we are committed to a more than human approach?<br /><br />
How, through public art practice, do we not colonize yet again?<br /><br />
How not to be extractive in our thinking and respond by listening, with specificity and with openness?

                        </div>
                </div>
        		<div class="section" id="recommendation">
                    <div class="big-3">
                        The following are a series of recommendations for a more-than-human public art practice, contributing to the research questions: If we reflect on the tree’s relation to time and territory, might it perform as precedent in how we regard resilience, permanence, ephemerality, legality and land within public art practice? How does thinking through time of a tree address other temporalities that may exist?<br />Recommendations have been generated in conversation with Tsēma Igharas, Natasha Myers, Zoe Todd, Natalie Jeremijenko and FRAUD (Fran Gallardo & Audrey Samson), Patricio Davila (Public Visualization Lab), Joanna Gutowska, Lisa Smith, Linda Columbus, Ali Qadeer and Shaheer Tarar.
                        <br /><br/>
                        
                        <li>Touch and work through materials to create proximal connections to territory across intergenerational time</li>
                        <li>Live beyond a human temporality and attend to the resulting reciprocal responsibilities</li>
                        <li>Reinvent mutualistic relations in more imaginative territorial sharings beyond industrial logics</li>
                        <li>Think of ecologies as happenings, as gatherings of happenings that bring together multiple beings and multiple temporalities</li>
                        <li>Find ways to conspire with the plants</li>
                        <li>Rewrite how we move and inhabit our bodies in actual space as a strategy to explore, very material, very sensual, very embodied interrelationships</li>
                        <li>Decolonize the logic of ecology which hinges on the efficiency of nature</li>
                        <li>Attune to relations to include technology, to include all aspects of human-made environments including the petrochemicals and contaminations <li>that are part of the ecology we're documenting</li>
                        <li>Look to trees and plants to teach us new things about the more than life of ecology but also the more than natural, in order to do a more-than-natural history</li>
                        <li>Restage relationships not based on extractive logics, not based on colonial forms, not but actually figuring out ways to conspire for livable futures for both plants and people</li>
                        <li>Tune into a different kind of time. Trees teach us about folds in time, deep ways to rethink tempos, temporalities, both speed of slowness. <li>
                        <li>begin in a world that isn't gridded yet, then begin to ask what matters. </li>
                        <li>Understand the porosities of the body and the fact that there are temporalities internally that are resonating with tree temporalities or other sentient beings</li>
                        <li>Centered around the body but rethinking the body itself</li>
                        <li>Using fish and plans and other creatures as a kind of council who are deliberating </li>
                        <li>Bring art into ongoing relationships to indigenous legal traditions</li>
                        <li>Realized the everyday relationships to space, people, and the land</li>
                        <li>Connect to t he territory through material; interact with material and connecting it back to territory</li>
                        <li>Break the binary of pain and love and respect and response</li>
                        <li>Tree is occupying land but it is then also responding to land inside the territory. simultaneously occupying two opposite positions, moving beyond the binary of one or the other and maybe it's more about how to teeter between both  </li>
</div>

                </div>
        		<div class="section" id="participants">
                    <div class="big-5">
                        <u>Presented by:</u><br />
                        <div class='participant'>Onsite Gallery</div><br />
                        <br />
                        <u>Curated by:</u><br />
                        <div class='participant'><span class="name">Ala Roushan</span>
                            <div class="bio">is an Assistant Professor at the Ontario College of Art and Design University. Her practice includes research, writing, curating and teaching.  She is a Ph.D. candidate at the European Graduate School in Philosophy, Art & Critical Thought and holds a Master of Arts in Advanced Architectural Design from Städelschule. Her current research navigates the implications of the digital as it reveals depth of space beyond the limits of human perception. Previously she was active as a founder of Flip Project Space Napoli, and most recently, Ala has been commission as the co-director/curator of SUGAR, an experimental curatorial platform based in Toronto.
<a href="https://independent.academia.edu/AlaRoushan">independent.academia.edu/AlaRoushan</a>
</div></div>
                        <div class='participant'><span class="name">Maiko Tanaka</span>
                            <div class="bio">
                                is the Executive Director of Squeaky Wheel Film & Media Art Center and an independent curator based in Buffalo and Toronto. Since 2007 Maiko has curated projects at the Justina M. Barnicke Gallery (now Art Museum at the University of Toronto) Gendai Gallery, Trinity Square Video, and Casco (in Utrecht), among others. She is co-editor of the publications, The Grand Domestic Revolution Handbook published by Casco and Valiz, and Model Minority, published by Gendai in collaboration with the Publication Studio, and has written texts for various art magazines and artist publications. Her curatorial research is informed by science-fiction feminisms, media and technology studies, non-linear forms of storytelling, and more-than-human approaches to creating and disseminating knowledge. She holds a BFA from OCAD University and an MVS from the University of Toronto. 
<a href="http://maikotanaka.com/">maikotanaka.com</a>

                            </div>
                        </div>
                        <br />
                        <u>Speakers:</u><br />
                            <div class='participant'><span class="name">Zoe Todd</span>
                            <div class="bio">(Métis/otipemisiw) is from amiskwaciwâskahikan (Edmonton), Alberta, Canada. She writes about fish, art, Métis legal traditions, the Anthropocene, extinction, and decolonization in urban and prairie contexts. She also studies human-animal relations, colonialism and environmental change in north/western Canada.
<a href="https://zoesctodd.wordpress.com/">zoesctodd.wordpress.com</a>
</div></div>
                        <div class='participant'><span class="name">Natasha Myers</span>
                            <div class="bio">is Associate Professor of Anthropology at York University, convenor of the Politics of Evidence Working Group, and director of the Plant Studies Collaboratory. Trained as a dancer, scientist, and anthropologist, her research and creative practice converge around questions of forms of vegetal life in the arts, sciences, and ecology. Her recent work includes Becoming Sensor (<a href="http://becomingsensor.com">becomingsensor.com</a>), a research-creation collaboration with dancer and filmmaker <u>Ayelen Liberona</u> that aims to decolonize our ecological sensorium. For more information see <a href="http://natashamyers.org">natashamyers.org</a>. </div></div>
                        <div class='participant'><span class="name">FRAUD</span>
                            <div class="bio">is a duo (FRan Gallardo + AUDrey Samson) of media and spatial thingkers. Their backgrounds include computational culture, critical technical practices, post-colonial and critical feminism, performance, design and space system engineering. They develop forms of art-led inquiry into the multiples scales of power, governability that flow through physical and cultural landscapes. Their practice is currently focused on exploring forms of slow violence and death embedded in, for instance, the entanglement between archiving practices and technical objects, the diminishing negantropism of global trade, systems of production after erasure, and alluring myths of ecological cosmopolitanism.
<a href="http://fraud.la">fraud.la</a>
</div></div>
   <div class='participant'><span class="name">Tsēma Igharas</span>
                            <div class="bio">is an interdisciplinary artist and a member of the Tāłtān First Nation. She uses Potlatch methodology to create conceptual artwork influenced by her mentorship in Northwest Coast Formline Design at K’saan (2005/06), her studies in visual culture and time in the mountains. She has a Bachelor's degree from Emily Carr University of Art and Design (2011) and graduated from the Interdisciplinary Master's in Art, Media and Design program at OCADu showing her thesis work, LAND|MINE that connects materials to mine sites and bodies to the land. Tsēma has shown and performed in various places in Canada, and internationally in Chiapas, Mexico, Asheville, USA and Santiago, Chile. 
<a href="http://www.esln.ca/">esln.ca</a>
</div></div>                        <br />
                        <u>Panelists:</u><br />
                        <div class='participant'><span class="name">Patricio Davilla</span>
                            <div class="bio">is a designer, artist and educator. He is currently Associate Professor in Design and Associate Dean at OCAD University. He is also member of the OCADU Mobile Media Lab and Visual Analytics Lab. Patricio is director of Public Visualization Lab. His doctoral research focused on developing a theoretical framework for examining data visualization as assemblages of subjectivation and power. In his creative practice he has created mobile applications, locative media projects, essay videos, new media installations, and participatory community projects including: Powers of Kin, Chthuluscene, Tent City Projections, The Line, and In The Air Tonight. His research and practice focuses on the politics and aesthetics of participation in the visualization of spatial issues with a specific focus on urban experiences, mobile technologies and large-scale interactive public installations.
<a href="http://patriciodavila.com/projects/">patriciodavila.com/projects</a>

</div></div>
                        <div class='participant'><span class="name">Tsēma Igharas</span>
                            <div class="bio">is an interdisciplinary artist and a member of the Tāłtān First Nation. She uses Potlatch methodology to create conceptual artwork influenced by her mentorship in Northwest Coast Formline Design at K’saan (2005/06), her studies in visual culture and time in the mountains. She has a Bachelor's degree from Emily Carr University of Art and Design (2011) and graduated from the Interdisciplinary Master's in Art, Media and Design program at OCADu showing her thesis work, LAND|MINE that connects materials to mine sites and bodies to the land. Tsēma has shown and performed in various places in Canada, and internationally in Chiapas, Mexico, Asheville, USA and Santiago, Chile. 
<a href="http://www.esln.ca/">esln.ca</a>
</div></div>
                        <div class='participant'><span class="name">Natasha Myers</span>
                            <div class="bio">is Associate Professor of Anthropology at York University, convenor of the Politics of Evidence Working Group, and director of the Plant Studies Collaboratory. Trained as a dancer, scientist, and anthropologist, her research and creative practice converge around questions of forms of vegetal life in the arts, sciences, and ecology. Her recent work includes Becoming Sensor (<a href="http://becomingsensor.com">becomingsensor.com</a>), a research-creation collaboration with dancer and filmmaker <u>Ayelen Liberona</u> that aims to decolonize our ecological sensorium. For more information see <a href="http://natashamyers.org">natashamyers.org</a>. </div></div>


 <div class='participant'><span class="name">Ala Roushan</span>
                            <div class="bio">is an Assistant Professor at the Ontario College of Art and Design University. Her practice includes research, writing, curating and teaching.  She is a Ph.D. candidate at the European Graduate School in Philosophy, Art & Critical Thought and holds a Master of Arts in Advanced Architectural Design from Städelschule. Her current research navigates the implications of the digital as it reveals depth of space beyond the limits of human perception. Previously she was active as a founder of Flip Project Space Napoli, and most recently, Ala has been commission as the co-director/curator of SUGAR, an experimental curatorial platform based in Toronto.
<a href="https://independent.academia.edu/AlaRoushan">independent.academia.edu/AlaRoushan</a>
</div></div>
                        <div class='participant'><span class="name">Maiko Tanaka</span>
                            <div class="bio">
                                is the Executive Director of Squeaky Wheel Film & Media Art Center and an independent curator based in Buffalo and Toronto. Since 2007 Maiko has curated projects at the Justina M. Barnicke Gallery (now Art Museum at the University of Toronto) Gendai Gallery, Trinity Square Video, and Casco (in Utrecht), among others. She is co-editor of the publications, The Grand Domestic Revolution Handbook published by Casco and Valiz, and Model Minority, published by Gendai in collaboration with the Publication Studio, and has written texts for various art magazines and artist publications. Her curatorial research is informed by science-fiction feminisms, media and technology studies, non-linear forms of storytelling, and more-than-human approaches to creating and disseminating knowledge. She holds a BFA from OCAD University and an MVS from the University of Toronto. 
<a href="http://maikotanaka.com/">maikotanaka.com</a>

                            </div>
                        </div>
                   



                        <div class='participant'><span class="name">Zoe Todd</span>
                            <div class="bio">(Métis/otipemisiw) is from amiskwaciwâskahikan (Edmonton), Alberta, Canada. She writes about fish, art, Métis legal traditions, the Anthropocene, extinction, and decolonization in urban and prairie contexts. She also studies human-animal relations, colonialism and environmental change in north/western Canada.
<a href="https://zoesctodd.wordpress.com/">zoesctodd.wordpress.com</a>
</div></div>
                        <br />
                        <u>Participants</u><br />
                        <div class='participant'><span class="name">Natalie Jeremijenko</span>
                            <div class="bio">In 2014 VIDA Art and Artificial Life International Awards Pioneer Prize was awarded to Natalie Jeremijenko "for her consistently brilliant portfolio of work over the past two decades.” (a prize only awarded once before to Laurie Anderson). Awarded the 2013 Most Innovative People, named of the most influential women in technology 2011, one of the inaugural top young innovators by MIT Technology Review and 40 most influential designers Jeremijenko directs the Environmental Health Clinic, and is an Associate Professor in the Visual Art Department, NYU and affiliated with the Computer Science Dept and Environmental Studies program. Previously she was on the Visual Arts faculty at UCSD, Faculty of Engineering at Yale University, a visiting professor at Royal College of Art in London, a Distinguished Visiting Professor in the Public Understanding of Science at Michigan State University, and a Visiting Global Distinguished Professor at they NYU College of Arts and Sciences. Her degrees are in biochemistry, engineering, neuroscience and History and Philosophy of Science.
<a href="http://www.nyu.edu/projects/xdesign/" target="_blank">http://www.nyu.edu/projects/xdesign/</a>
</div></div>
                        <br />
                        <u>Soil Cola Recipe:</u><br />
                        <div class='participant'><span class="name">FRAUD</span>
                            <div class="bio">is a duo (FRan Gallardo + AUDrey Samson) of media and spatial thingkers. Their backgrounds include computational culture, critical technical practices, post-colonial and critical feminism, performance, design and space system engineering. They develop forms of art-led inquiry into the multiples scales of power, governability that flow through physical and cultural landscapes. Their practice is currently focused on exploring forms of slow violence and death embedded in, for instance, the entanglement between archiving practices and technical objects, the diminishing negantropism of global trade, systems of production after erasure, and alluring myths of ecological cosmopolitanism.
<a href="http://fraud.la">fraud.la</a>
</div></div>
                        <br />
                        <u>Terrascreen:</u><br />
                        <div class='participant'><span class="name">Ali S. Qadeer</span>
                            <div class="bio">is a designer and educator in Toronto. His work focuses on algorithmic form and where graphic design meets the humanities. An Assistant Professor at OCAD University with an MFA from RISD, Ali works in web, print, and web and print.
<a href="http://work.iamasq.ca/">work.iamasq.ca</a>
 
</div></div>
                        <div class='participant'><span class="name">Shaheer Tarar</span>
                            <div class="bio">is a documentary artist and designer from Toronto. He uses satellite images, found footage and legal documents to trace historical events to the role they play in the contemporary moment, and presents these studies as publications, websites, large prints or multi-channel films. Shaheer is a recent graduate of OCAD University.
<a href="http://sheeri.co">sheeri.co</a> </div></div>
                        <br />
                    </div>
                </div>
        		<div class="section" id="event">need content here.</div>
        		<div class="section" id="contact">
                    <div class="big-5">
                        Curated by Ala Roushan and Maiko Tanaka<br />
                        Presented by Onsite Gallery<br /><br />
                        Onsite Gallery gratefully acknowledges the Ontario Arts Council for their support through the Culturally Diverse Curatorial Project program.
                    </div>
                </div>
        		<div class="section" id="legend">
                    <div class="big-5">
                        
The opening projection presents seven characters living, reproducing, dying, feeding and killing based on their interactions with each other and the world around them. Each species lives within their own temporality and affects the species they come into contact with. Terrascreen highlights and synthesizes fragments of TREE TEMPORALITY’s research into a narrative that builds awareness of the multi-species agencies within our environment.<br /><br />
                        <table>
                            <tr>
                                <td>
                                    <img src="images/spruce.png" class="icon">
                                </td>
                                <td>
                                    White spruce<br />
                                    With a genome ten times the scale of that of a human genome, white spruce contains a volume of information and experience that simultaneously plays at a quick time and a slow time.<br /><br />

                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                    <img src="images/sturgeon.png" class="icon">
                                </td>
                                <td>
                                    Sturgen<br />
                                    A healthy sturgeon, such as those in Treaty 6 territory can live to 150 years old—far beyond a human lifespan.<br /><br /> 

                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                    <img src="images/territory.png" class="icon">
                                </td>
                                <td>
                                    Tahltan territory<br />
                                    This area exists not as a static region but of an active, interdependent space. Through gift and return—the obsidian, copper, and rawhide continue to change the land. <br /><br />
                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                    <img src="images/edziza.png" class="icon">
                                </td>
                                <td>
                                Mount Edziza<br />
                                A volcano rich with obsidian, Mount Ediziza’s very composition was collected and proliferated across the region by ancient Tahltan people. This world changes in both geological and anthropocenic time.<br /><br />

                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                    <img src="images/tailings.png" class="icon">
                                </td>
                                <td>                                    
                                    Mount Polley<br />
                                    In 2014, the Mount Polley tailings pond breached and polluted the water systems in the surrounding land. Life and territory can be affected within comparative instants.<br /><br />
                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                <img src="images/city.png" class="icon">
                                </td>
                                <td>
                                    City<br />
                                    The city shapes itself around the trees that live within its growing borders. Its dwellers could have removed them to favor a grid, instead their architecture forms around the trees.<br /><br />
                                </td>
                            </tr>
                            
                            <tr>
                                <td>
                                    <img src="images/kokanee.png" class="icon">
                                </td>
                                <td>
                                    Kokanee<br /> 
                                    Found in Tahltan territory, Kokanee (Salmon) are a migratory fish found throughout Tahltan territory. <br /><br />
                                </td>
                            </tr>
                        </table>








                    
                    </div>
        	</div>
        </div>

		<script>
			$(document).ready(function(){

$(".menu, .tt").click(function(){
    a = "#"+$(this).attr("id").replace("menu-","");
    
    $.scrollTo(a,200);

    $(".menu").removeClass("active");
    $(this).addClass("active")
});

                
                $(".tt").click(function(){
                    console.log("f");
                })

    $(document).scroll(function(){


        $(".section").each(function(){

            var docViewTop = $(document).scrollTop();
            var docViewBottom = docViewTop + $(window).height();
            var elemTop = $(this).offset().top;
            var elemBottom = elemTop + $(this).height();
            
                if (docViewTop >= elemTop-50) {
                     $(".menu").removeClass("active");
                     $("#menu-"+$(this).attr("id")).addClass("active") ;
                }

            })


        
        // $(".section").each(function(){
        //     var docViewTop = $(document).scrollTop();
        //     var docViewBottom = docViewTop + $(window).height();

        //     var elemTop = $(this).offset().top;
        //     var elemBottom = elemTop + $(this).height();

        //     if ((elemBottom <= docViewBottom) && (elemTop >= docViewTop)) {
        //         console.log("f");
        //     }
        // })

    });

})


		</script>

            <script>
    
//var socket = io();
  
var city = [];
var trunks = [];
var branches = [];
var sturgeon = [];
var mountain;
var territory;
var flock;
var pond;

var pondLeak = false;

var FPS = 60;

var treeLimit = 30;
var branchLimit = 180; //should be tree Limit * tree.branchAllow
var treeTemp = 5 * FPS; //in seconds

function preload() {
  //myFont = loadFont('fonts/sm.otf');
}

function setup() {
    var windowWidth = $(window).width();
    var windowHeight = $(window).height();
    //textFont(myFont);
    createCanvas(windowWidth, windowHeight);
    
    territory = new Territory();
    territory.start();
    
    mountain = new Mountain();
    mountain.start();
    
    city = new City()
    
    pond = new Pond();
    pond.start();
    
    for (var i=0; i < 1; i++){
        sturgeon.push(new Sturgeon());
    };
    
    for (var i=0; i < 1; i++) {
        trunks.push(new Trunk());
    }
    
    flock = new Flock();
    
    for (var i = 0; i < 4; i++) {
        flock.addBoid();
    }
}

function draw() {
    background(0);
    
    mountain.display();
    mountain.decay();
    
    territory.display();
    territory.update();
    
    flock.run();
    
    city.display();
    city.grow();
    
    pond.display();
    
    for (var i=0; i < sturgeon.length; i++){
        sturgeon[i].display();
        sturgeon[i].move();
        sturgeon[i].checkCollision();
    }
    
    for (var i=0; i<trunks.length; i++){
        trunks[i].display();
        trunks[i].grow();
        trunks[i].checkCollision(i);
    };
    
    for (var i=0; i<branches.length; i++){
        branches[i].display();
        branches[i].grow();
        branches[i].checkCollision(i);
    }
    
    if (frameCount % treeTemp == 0){ //keep automaitcally growing trees
        if (trunks.length < treeLimit){
            trunks.push(new Trunk());
        };
    };
    
    if (pondLeak == true){
        pond.leak();
        pond.checkCollision();
    };
    
    if (flock.boids.length < 4){ 
        flock.addBoid();
    };
    fill(255, 255, 255);
//    blendMode(DIFFERENCE);
//    t = "TREE\nTEMPORALITY\n\nmulti-species research on time, territory and public art practice\n\nOCADU UNIVERSITY\nNovember 25th, 2017";
//    textSize(30);
//    text(t, 30, 30, 500,500);
    blendMode(BLEND);
    
}

function mouseClicked(){
    sturgeon[0].death();
}

function Trunk() {
    this.x = random(width);
    this.y = random(100, height);
    this.w = 4;
    this.h = 4;
    this.pixelArray = [];
//    this.growLimit = 20; //BACKUP
    this.growLimit = cam2;
    this.stopGrowth = false;
    
    this.branchAllow = 6;
    
//    this.temp = 1 * FPS //BACKUP
    this.temp = cam1; //in frames
    
    this.display = function() {
        for (var i=0; i < this.pixelArray.length; i++) {
            fill(255);
            noStroke();
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function() {
        if (frameCount % this.temp == 0){
            if (this.stopGrowth == false){
                if (this.pixelArray.length < this.growLimit){
                    this.y -= 4;
                    this.x += random(-2, 2);
                    this.pixelArray.push([this.x, this.y, this.w, this.h]);
                } else if (this.pixelArray.length == this.growLimit){
                    this.branchAllow = this.branchAllow - 2;
                    branches.push(new Branch(this.x, this.y, 'left', this.branchAllow/2));
                    branches.push(new Branch(this.x, this.y, 'right', this.branchAllow/2)); 
                    this.stopGrowth = true;
                    console.log('2 New Branches: ' + branches.length + ' branches on screen');
                };
            };
        };
    }
    
    this.checkCollision = function(trunkIndex){
        //figure out location of sturgeon's mouth
        if (sturgeon[0].xDir == 'left'){
            var sturMouthX = sturgeon[0].x;
            var sturMouthY = sturgeon[0].y;
        } else if (sturgeon[0].xDir == 'right'){
            var sturMouthX = sturgeon[0].x + 24 + (12 * (sturgeon[0].body + 1));
            var sturMouthY = sturgeon[0].y;
        };
        
        for (var i=this.pixelArray.length-1; i >=0; i--){ //for each pixel in trunk
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(sturMouthX, sturMouthY, sturgeon[0].w, sturgeon[0].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collision){
                this.death(trunkIndex);
                sturgeon[0].grow();
                break;
            };
        };
        
        branchTrunk:
        for (var i=this.pixelArray.length - 1; i >= 0; i--){// for each pixel in trunk
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].w, flock.boids[k].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    this.death(trunkIndex);
                    flock.grow();
                    break branchTrunk;
                };
            };
        };
    }
    
    this.death = function(trunkIndex){
        trunks.splice(trunkIndex, 1); //remove this tree from array
        if (trunks.length < treeLimit){ ///grow another tree if trees are less than treeLimit
            trunks.push(new Trunk());
            console.log('New Tree: ' + trunks.length + ' live trees on screen');
        };
    }
}

function Branch(x, y, d, b) {
    this.x = x;
    this.y = y;
    this.w = 4;
    this.h = 4;
    
    this.branchAllow = b;
    
//    this.temp = 1 * FPS; //BACKUP in seconds
    this.temp = cam1; //in frames

    this.yArray = [2,4];
    this.yRand = this.yArray[round(random(1))];
    this.d = d;
    
    this.pixelArray = [];
//    this.growLimit = 20; //BACKUP
    this.growLimit = cam2;
    this.stopGrowth = false;
    
    this.display = function(){
        for (var i=0; i < this.pixelArray.length; i++) {
            fill(255);
            noStroke();
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function(){
        if (frameCount % this.temp == 0){
            if (this.stopGrowth == false){
                if (this.pixelArray.length < this.growLimit){
                    if (this.d == 'left'){
                        this.y -= this.yRand;
                        this.x += random(-4, 0);
                        this.pixelArray.push([this.x, this.y, this.w, this.h]);
                    } else if (this.d == 'right'){
                        this.y -= this.yRand;
                        this.x += random(0, 4);
                        this.pixelArray.push([this.x, this.y, this.w, this.h]);
                    };
                } else if (this.pixelArray.length == this.growLimit){
                    this.stopGrowth = true;
                    if (branches.length < branchLimit){ //if more branches are allowed on page
                        if (this.branchAllow > 0){ //if more branches are allowed on tree
                            this.branchAllow = this.branchAllow - 2;
                            branches.push(new Branch(this.x, this.y, 'left', this.branchAllow/2)); 
                            branches.push(new Branch(this.x, this.y, 'right', this.branchAllow/2));
                            console.log('2 New Branches: ' + branches.length + ' branches on screen');
                        };
                    }
                };
            };
        };
    }
    
    this.checkCollision = function(branchIndex){
        //figure out location of sturgeon's mouth
        if (sturgeon[0].xDir == 'left'){
            var sturMouthX = sturgeon[0].x;
            var sturMouthY = sturgeon[0].y;
        } else if (sturgeon[0].xDir == 'right'){
            var sturMouthX = sturgeon[0].x + 24 + (12 * (sturgeon[0].body + 1));
            var sturMouthY = sturgeon[0].y;
        };
        
        for (var i=this.pixelArray.length - 1; i >= 0; i--) { //for each pixel in branch 
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(sturMouthX, sturMouthY, sturgeon[0].w, sturgeon[0].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collision){
                this.death(branchIndex);
                sturgeon[0].grow();
                break;
            };
        };
        
        branchKokanee:
        for (var i=this.pixelArray.length - 1; i >=0; i--){// for each pixel in branch
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].w, flock.boids[k].h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    this.death(branchIndex);
                    flock.grow();
                    break branchKokanee;
                };
            };
        };

    }
    
    this.death = function(branchIndex){
        branches.splice(branchIndex, 1); //remove this branch from array
    }
}

function City() {
    this.x = random(width);
    this.y = random(height);
    this.w = 2;
    this.h = 2;
    
    this.xyArray = [-2, 2];
    this.pixelArray = [];
    
    this.temp = 0.05 * FPS; //in seconds
    
    this.display = function() {
        for (var i=0; i < this.pixelArray.length; i ++){
            fill(255);
            stroke(255);
            strokeWeight(2);
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.grow = function() {
        if (frameCount % this.temp == 0){
            var xRand = this.xyArray[round(random(1))];
            var yRand = this.xyArray[round(random(1))];

            this.x += xRand;
            this.y += yRand;
            var collisionDetected = this.checkCollision();

            if (collisionDetected == false){
                this.pixelArray.push([this.x, this.y, this.w, this.h]);
            };
        };
    }
    
    this.checkCollision = function() {
        var anyCollision = false;
        //check for collision with other city pixels
        for (var i=0; i < this.pixelArray.length; i ++){
            var collide = collideRectRect(this.x, this.y, this.w, this.h, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };
        
        //check for collision with trunk
        for (var i=0; i < trunks.length; i++){// for each trunk
            for (var k=0; k < trunks[i].pixelArray.length; k++){// for each pixel of each trunk
                var collide = collideRectRect(this.x, this.y, this.w, this.h, trunks[i].pixelArray[k][0], trunks[i].pixelArray[k][1], trunks[i].pixelArray[k][2], trunks[i].pixelArray[k][3]);
                if (collide == true){
                    anyCollision = true;
                };
            };
        };
        
        //check for collision with branches
        for (var i=0; i < branches.length; i++){// for each branch
            for (var k=0; k < branches[i].pixelArray.length; k++){// for each pixel of each branch
                var collide = collideRectRect(this.x, this.y, this.w, this.h, branches[i].pixelArray[k][0], branches[i].pixelArray[k][1], branches[i].pixelArray[k][2], branches[i].pixelArray[k][3]);
                if (collide == true){
                    anyCollision = true;
                };
            };
        };
        
        //check for collision with mountain
        for (var i=0; i < mountain.pixelArray.length; i++){
            var collide = collideRectRect(this.x, this.y, this.w, this.h, mountain.pixelArray[i][0], mountain.pixelArray[i][1], mountain.pixelArray[i][2], mountain.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };
        
        //check for collision with pond
        for (var i=0; i < pond.pixelArray.length; i++){ //for each pixel of pond
            var collide = collideRectRect(this.x, this.y, this.w, this.h, pond.pixelArray[i][0], pond.pixelArray[i][1], pond.pixelArray[i][2], pond.pixelArray[i][3]);
            if (collide == true){
                anyCollision = true;
            };
        };

        //check for collision with bounds
        if (this.x < 0 || this.y < 0 || this.x > (width - this.w) || this.y > (height - this.h)){
            anyCollision = true;
        };
        
        return anyCollision;
    }
}

function Sturgeon() {
    this.x = random(width);
    this.y = random(height);
    this.w = 4;
    this.h = 4;
    
    this.xDir = 'right';
    this.xMoveArray = [50, 100, 200, 300, 400];
    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
    this.xMoveCount = 0;
    
    this.yDir = 'up';
    this.yMoveArray = [10, 20, 30, 40, 50, 60, 70, 80];
    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
    this.yMoveCount = 0;
    
    this.fishTop;
    this.fishLeft;
    this.fishRight;
    this.fishBottom;
    
    this.feed = 0;
    this.maxFeed = 10;
    this.body = 0;
    this.bodyMax = 12;
    
    this.display = function(){
        fill(255);
        noStroke();
        
        if (this.xDir == 'left'){
            //head
            rect(this.x, this.y, this.w, this.h);

            rect(this.x + 4, this.y - 4, this.w, this.h);
            rect(this.x + 4, this.y + 4, this.w, this.h);

            rect(this.x + 8, this.y - 8, this.w, this.h);
            rect(this.x + 8, this.y - 4, this.w, this.h);
            rect(this.x + 8, this.y, this.w, this.h);
            rect(this.x + 8, this.y + 4, this.w, this.h);
            rect(this.x + 8, this.y + 8, this.w, this.h);

            rect(this.x + 12, this.y - 4, this.w, this.h);
            rect(this.x + 12, this.y, this.w, this.h);
            rect(this.x + 12, this.y + 4, this.w, this.h);

            rect(this.x + 16, this.y, this.w, this.h);

            //body
            for (var i=0; i <= this.body; i++){
                var mult = 20 + (12 * i);
                var bodyY = this.y;

                rect(this.x + mult, bodyY - 8, this.w, this.h);
                rect(this.x + mult, bodyY - 4, this.w, this.h);
                rect(this.x + mult, bodyY + 4, this.w, this.h);
                rect(this.x + mult, bodyY + 8, this.w, this.h);

                rect(this.x + mult + 4, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 4, bodyY, this.w, this.h);
                rect(this.x + mult + 4, bodyY + 4, this.w, this.h);

                rect(this.x + mult + 8, bodyY, this.w, this.h);
            };

            //tail
            var tailX = 20 + (12 * (this.body + 1));

            rect(this.x + tailX, this.y - 4, this.w, this.h);
            rect(this.x + tailX, this.y, this.w, this.h);
            rect(this.x + tailX, this.y + 4, this.w, this.h);

            rect(this.x + tailX + 4, this.y - 8, this.w, this.h);
            rect(this.x + tailX + 4, this.y - 4, this.w, this.h);
            rect(this.x + tailX + 4, this.y + 4, this.w, this.h);
            rect(this.x + tailX + 4, this.y + 8, this.w, this.h);
            
        } else if (this.xDir == 'right'){
            
            //tail
            rect(this.x, this.y - 8, this.w, this.h);
            rect(this.x, this.y - 4, this.w, this.h);
            rect(this.x , this.y + 4, this.w, this.h);
            rect(this.x, this.y + 8, this.w, this.h);

            rect(this.x + 4, this.y - 4, this.w, this.h);
            rect(this.x + 4, this.y, this.w, this.h);
            rect(this.x + 4, this.y + 4, this.w, this.h);

            //body
            for (var i=0; i <= this.body; i++){
                var mult = 8 + (12 * i);
                var bodyY = this.y;
                
                rect(this.x + mult, bodyY, this.w, this.h);
                
                rect(this.x + mult + 4, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 4, bodyY, this.w, this.h);
                rect(this.x + mult + 4, bodyY + 4, this.w, this.h);

                rect(this.x + mult + 8, bodyY - 8, this.w, this.h);
                rect(this.x + mult + 8, bodyY - 4, this.w, this.h);
                rect(this.x + mult + 8, bodyY + 4, this.w, this.h);
                rect(this.x + mult + 8, bodyY + 8, this.w, this.h);
            };
            
            //head
            var HeadX = 8 + (12 * (this.body + 1));
            
            rect(this.x + HeadX, this.y, this.w, this.h);

            rect(this.x + HeadX + 4, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 4, this.y, this.w, this.h);
            rect(this.x + HeadX + 4, this.y + 4, this.w, this.h);

            rect(this.x + HeadX + 8, this.y - 8, this.w, this.h);
            rect(this.x + HeadX + 8, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 8, this.y, this.w, this.h);
            rect(this.x + HeadX + 8, this.y + 4, this.w, this.h);
            rect(this.x + HeadX + 8, this.y + 8, this.w, this.h);

            rect(this.x + HeadX + 12, this.y - 4, this.w, this.h);
            rect(this.x + HeadX + 12, this.y + 4, this.w, this.h);

            rect(this.x + HeadX + 16, this.y, this.w, this.h);
        };
    }
    
    this.grow = function(){
        this.feed++;
        console.log('Sturgeon has eaten ' + this.feed + ' branches');
        if (this.feed % this.maxFeed == 0){
            this.body++;
            console.log('Sturgeon has grown to size ' + this.body);
        };
        if (this.body == this.bodyMax){
            this.death();
            console.log('Sturgeon has died');
        };
    }
    
    this.move = function(){ 
        // DETERMINE FISH DIMENSIONS
        this.fishTop = this.y - 12;
        this.fishLeft = this.x;
        this.fishRight = this.x + 20 + 8 + (12 * (this.body + 1));
        this.fishBottom = this.y + 12;
        
        if (this.fishTop < 0){ //if fish hits top of frame, move down
            this.yDir = 'down'
            this.yMoveCount = 0;
            this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
        } else if (this.fishLeft < 0){ //if fish hits left edge of frame, move right
            this.xDir = 'right'
            this.xMoveCount = 0;
            this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
        } else if (this.fishRight > windowWidth){ //if fish hits right edge, move left
            this.xDir = 'left'
            this.xMoveCount = 0;
            this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
        } else if (this.fishBottom > windowHeight){ //if fish hits bottom, move up
            this.yDir = 'up'
            this.yMoveCount = 0;
            this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
        };
        
        // DETERMINE LEFT OR RIGHT
        if (this.xMoveCount == this.xMove){
            if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                this.xDir = 'left'
                this.xMoveCount = 0;
                this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
            } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                this.xDir = 'right'
                this.xMoveCount = 0;
                this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
            };
        };
        
        // MOVE LEFT OR RIGHT 
        if (this.xDir == 'left'){
            this.x--;
            this.xMoveCount++;
        } else if (this.xDir == 'right'){
            this.x++;
            this.xMoveCount++;
        };
        
        // DETERMINE UP OR DOWN
        if (this.yMoveCount == this.yMove){ //if fish yMoveCount is equal to yMove
            if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                this.yDir = 'down'
                this.yMoveCount = 0;
                this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
            } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                this.yDir = 'up'
                this.yMoveCount = 0;
                this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
            };
        };
        
        // MOVE UP OR DOWN
        if (this.yDir == 'up'){ //if fish direction is up, go up
            this.y--;
            this.yMoveCount++;
        } else if (this.yDir == 'down'){ //if fish direction is down, go down
            this.y++;
            this.yMoveCount++;
        };
    }
    
    this.checkCollision = function(){
        //figure out location of sturgeon's mouth
        var fishX = this.x;
        var fishY = this.y;
        var fishW = 28 + (12 * (this.body + 1));
        var fishH = 20;
        
        // check for collision with city
        for (var i=0; i < city.pixelArray.length; i++){ //for each pixel in city
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(fishX, fishY, fishW, fishH, city.pixelArray[i][0], city.pixelArray[i][1], city.pixelArray[i][2], city.pixelArray[i][3]);
            
            if (collision){ //if collision with city, change direction
                console.log('Sturgeon Collision with City');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+=4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        };
        
        // check for collision with mountain
        for (var i=0; i < mountain.pixelArray.length; i++){ //for each pixel in mountain
            // check for collision with mouth of sturgeon
            var collision = collideRectRect(fishX, fishY, fishW, fishH, mountain.pixelArray[i][0], mountain.pixelArray[i][1], mountain.pixelArray[i][2], mountain.pixelArray[i][3]);
            if (collision){ //if collision with mountain, change direction
                console.log('Sturgeon Collision with Mountain');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+= 4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        };
        
        if (pondLeak == false){ //if pond has not leaked
            var pondWidth = pond.w*pond.pondWidth;
            var pondHeight = pond.h*pond.pondHeight

            var collision = collideRectRect(fishX, fishY, fishW, fishH, pond.x - pondWidth, pond.y, pondWidth, pondHeight);
            if (collision){ //if collision with mountain, change direction
                console.log('Sturgeon Collision with Tailings Pond');
                if (this.xDir == 'right'){ //if fish is going right, switch to left and reset xMoveCount, create new xMove
                    this.xDir = 'left'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x-= 4;
                } else if (this.xDir == 'left'){ //if fish is going down, switch to up and reset xMoveCount, create new xMove
                    this.xDir = 'right'
                    this.xMoveCount = 0;
                    this.xMove = this.xMoveArray[floor(random(this.xMoveArray.length))];
                    this.x+= 4;
                };
                
                if (this.yDir == 'up'){ //if fish is going up, switch to down and reset yMoveCount, create new yMove
                    this.yDir = 'down'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y+=4;
                } else if (this.yDir == 'down'){ //if fish is going down, switch to up and reset yMoveCount, create new yMove
                    this.yDir = 'up'
                    this.yMoveCount = 0;
                    this.yMove = this.yMoveArray[floor(random(this.yMoveArray.length))];
                    this.y-=4;
                };
            };
        } else if (pondLeak == true){
            for (var i=0; i < pond.pixelArray.length; i++){ //for each pixel of pond
                var collide = collideRectRect(fishX, fishY, fishW, fishH, pond.pixelArray[i][0], pond.pixelArray[i][1], pond.pixelArray[i][2], pond.pixelArray[i][3]);
                if (collide){
                    this.death();
                    console.log('Sturgeon killed by Tailing Pond leak');
                    break;
                }
            };
        };
    }
    
    this.death = function() {
        sturgeon.splice(0, 1);
        sturgeon.push(new Sturgeon);
        console.log('Sturgeon is born');
    }
}

function Mountain(){
    this.pixelArray = [];
    this.minedArray = [];
    
    this.height = 20;
    this.left = 24 + (this.height * 4);
    this.mountainWidth = 52 + (this.height * 8);
    this.mountainHeight = 20 + (this.height * 4);
    
    this.x = random(this.left, territory.x);
    this.y = random(height - this.mountainHeight);
    this.w = 4;
    this.h = 4;
    
    this.temp = 15 * FPS; //in seconds

    /// MOUNTAIN HEIGHT ///

    this.start = function(){
        for (var i=0; i <= this.height; i++){
            var mountY = 16 + (i * 4);
            var mountXPixels = 13 + (i * 2)
            for (var k=0; k <= floor(mountXPixels/2); k++){
                var mountX = k * 4;
                this.pixelArray.push([this.x + mountX, this.y + mountY, this.w, this.h]);
            };
            for (var k=1; k <= floor(mountXPixels/2); k++){
                var mountX = k * -4;
                this.pixelArray.push([this.x + mountX, this.y + mountY, this.w, this.h]);
            };
        };
    }
    
    this.display = function(){
        fill(255);
        noStroke();
        
        /// MOUNTAIN TOP ///
        rect(this.x - 8, this.y, this.w, this.h);
        rect(this.x - 4, this.y, this.w, this.h);
        rect(this.x, this.y, this.w, this.h);
        rect(this.x + 4, this.y, this.w, this.h);
        rect(this.x + 8, this.y, this.w, this.h);

        rect(this.x - 12, this.y + 4, this.w, this.h);
        rect(this.x + 12, this.y + 4, this.w, this.h);

        rect(this.x - 16, this.y + 8, this.w, this.h);
        rect(this.x + 16, this.y + 8, this.w, this.h);

        rect(this.x - 20, this.y + 12, this.w, this.h);
        rect(this.x - 16, this.y + 12, this.w, this.h);
        rect(this.x - 12, this.y + 12, this.w, this.h);
        rect(this.x + 12, this.y + 12, this.w, this.h);
        rect(this.x + 16, this.y + 12, this.w, this.h);
        rect(this.x + 20, this.y + 12, this.w, this.h);

        rect(this.x - 20, this.y + 12, this.w, this.h);
        rect(this.x - 16, this.y + 12, this.w, this.h);
        rect(this.x - 12, this.y + 12, this.w, this.h);
        rect(this.x + 12, this.y + 12, this.w, this.h);
        rect(this.x + 16, this.y + 12, this.w, this.h);
        rect(this.x + 20, this.y + 12, this.w, this.h);
        
        for (var i=0; i < this.pixelArray.length; i ++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
        
        for (var i=0; i < this.minedArray.length; i ++){
            rect(this.minedArray[i][0], this.minedArray[i][1], this.minedArray[i][2], this.minedArray[i][3]);
        };
    }
    
    this.decay = function(pixelArray){
        if (frameCount % this.temp == 0){
            if (this.pixelArray.length > 0){
                var pixelIndex = floor(random(this.pixelArray.length));
                this.pixelArray.splice(pixelIndex, 1);

                this.minedArray.push([random(territory.x), random(height), this.w, this.h]);
                console.log('1 Obsidian Mined: ' + this.pixelArray.length + ' Obsidain left in Mountain');
            };
        };
    }
}

function Territory(){
    this.x = width/3;
    this.y = 0;
    this.w = 4;
    this.h = 4;
    
    this.height = height/12;
    this.xArray = [-4, 0, 4];
    this.xRand = this.xArray[round(random(2))];
    this.temp = 1 * FPS //in seconds
    
    this.xUpdateArray = [-1, 0, 1];
    
    this.pixelArray = [];
    
    this.start = function(){
        for (var i=0; i <= this.height; i++){
            this.pixelArray.push([this.x, this.y, this.w, this.h]);
            
            this.y+=12;
            this.xRand = this.xArray[round(random(2))];
            this.x += this.xRand;
        };
    }
    
    this.display = function(){
        noStroke();
        fill(255);
        for (var i=0; i < this.pixelArray.length; i++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.update = function(){
        if (frameCount % this.temp == 0){
            this.x = width/3;
            this.y = 0;
            
            for (var i=0; i < this.pixelArray.length; i++){
                this.xRand = this.xUpdateArray[round(random(2))];
                this.pixelArray[i][0]+=this.xRand;
            };
        };
    }
}

function Pond(){
    this.pondWidth = 30;
    this.pondHeight = 20;
    
    this.w = 4;
    this.h = 4;
    
    this.x = random(width - (this.w*this.pondWidth));
    this.y = random(height - (this.h*this.pondHeight));
    this.yUpdate = 0;
    
    this.randArray = [-4, 0, 4];
    this.pixelArray = [];
    
    this.leakCount = 0;
    this.leakMax = 7200; // 
    this.newPondTime = 60000; //in ms
    
    this.start = function(){
        for (var i=0; i < this.pondWidth; i++){
            for (var k=0; k < this.pondHeight; k++){
                this.pixelArray.push([this.x, this.y + this.yUpdate, this.w, this.h]);
                this.yUpdate = this.yUpdate + 4;
            };
            this.yUpdate = 0;
            this.x = this.x + 4;
        };
    }
    
    this.display = function(){
        fill(255);
        noStroke();
        for (var i=0; i < this.pixelArray.length; i++){
            rect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
        };
    }
    
    this.leak = function(){
        this.leakCount++;
        if (this.leakCount < this.leakMax){
            for (var i=0; i < this.pixelArray.length; i++){
                var xRand = this.randArray[round(random(2))];
                var yRand = this.randArray[round(random(2))];
                this.pixelArray[i][0] = this.pixelArray[i][0] + xRand;
                this.pixelArray[i][1] = this.pixelArray[i][1] + yRand;
            };
        } else { //if leakMax is reached, reset pond
            this.pixelArray = [];
            this.leakCount = 0;
            pondLeak = false;
            this.x = random(width - (this.w*this.pondWidth));
            this.y = random(height - (this.h*this.pondHeight));
            setTimeout(function(){pond.start();}, this.newPondTime);
        };
    }
    
    this.checkCollision = function(){
        // check collision with trees
        for (var i=0; i < this.pixelArray.length; i++){//for each pixel in array
            for (var k=trunks.length-1; k >=0; k--){// for each trunk
                for (var m=0; m < trunks[k].pixelArray.length; m++){// for each pixel
                    var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], trunks[k].pixelArray[m][0], trunks[k].pixelArray[m][1], trunks[k].pixelArray[m][2], trunks[k].pixelArray[m][3]);
                    if (collision){
                        trunks[k].death(k);
                        break;
                    };
                };
            };
        };
        
        // check collision with branches
        for (var i=0; i < this.pixelArray.length; i++){//for each pixel in array
            for (var k=branches.length-1; k >=0; k--){// for each tree
                for (var m=0; m < branches[k].pixelArray.length; m++){// for each pixel of each tree
                    var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], branches[k].pixelArray[m][0], branches[k].pixelArray[m][1], branches[k].pixelArray[m][2], branches[k].pixelArray[m][3]);
                    if (collision){
                        branches[k].death(k);
                        break;
                    }
                };
            };
        };
        
        //check collision with city
        for (var i=this.pixelArray.length-1; i >=0 ; i--){//for each pixel in array
            for (var k=city.pixelArray.length-1; k>=0; k--){// for each pixel in city
                var collision = collideRectRect(this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3], city.pixelArray[k][0], city.pixelArray[k][1], city.pixelArray[k][3], city.pixelArray[k][1]);
                if (collision){
                    this.pixelArray.splice(i, 1);//remove pond pixel
                    city.pixelArray.splice(k, 1);//remove city pixel
                    break;
                };
            };
        };
        
        //check collision with kokanee
        for (var i=this.pixelArray.length-1; i >=0 ; i--){//for each pixel in array
            for (var k=flock.boids.length - 1; k >= 0; k--){// for each kokanee
                var collision = collideRectRect(flock.boids[k].position.x, flock.boids[k].position.y, flock.boids[k].h, flock.boids[k].w, this.pixelArray[i][0], this.pixelArray[i][1], this.pixelArray[i][2], this.pixelArray[i][3]);
                if (collision){
                    flock.death();
                    console.log('Kokanee killed by Toxic Waste');
                };
            };
        };
    }
}

function Flock() {
    this.boids = [];
    this.feed = 0;
    this.maxFeed = 20;
    this.maxBoids = 30;
    
    this.run = function() {
        for (var i = 0; i < this.boids.length; i++) {
            this.boids[i].run(this.boids);  // Passing the entire list of boids to each boid individually
        };
    }
    
    this.addBoid = function() {
        this.boids.push(new Boid(random(width), random(height)));
        console.log('1 New Kokanee: ' + this.boids.length + ' Kokanee on screen');
    }
    
    this.grow = function(){
        this.feed++;
        console.log('Kokanee have eaten ' + this.feed + ' branches');
        if (this.feed % this.maxFeed == 0){
            this.addBoid();
        };
        if (this.boids.length == this.maxBoids){
            this.death();
        };
    }
    
    this.death = function(){
        this.boids.splice(0, 1);
        console.log('A Kokanee has died');
    }
}

function Boid(x,y) {
    this.acceleration = createVector(0,0);
    this.velocity = createVector(random(-1,1),random(-1,1));
    this.position = createVector(x,y);
    this.r = 3.0;
    this.maxspeed = 3;    // Maximum speed
    this.maxforce = 0.05; // Maximum steering force
    this.w = 8;
    this.h = 4;
    
    this.run = function(boids) {
        this.flock(boids);
        this.update();
        this.borders();
        this.render();
    }
    
    this.applyForce = function(force) {
        // We could add mass here if we want A = F / M
        this.acceleration.add(force);
    }
    
    // We accumulate a new acceleration each time based on three rules
    this.flock = function(boids) {
        var sep = this.separate(boids);   // Separation
        var ali = this.align(boids);      // Alignment
        var coh = this.cohesion(boids);   // Cohesion
        // Arbitrarily weight these forces
        sep.mult(1.5);
        ali.mult(1.0);
        coh.mult(1.0);
        // Add the force vectors to acceleration
        this.applyForce(sep);
        this.applyForce(ali);
        this.applyForce(coh);
    }
    
    // Method to update location
    this.update = function() {
        // Update velocity
        this.velocity.add(this.acceleration);
        // Limit speed
        this.velocity.limit(this.maxspeed);
        this.position.add(this.velocity);
        // Reset accelertion to 0 each cycle
        this.acceleration.mult(0);
    }
    
    // A method that calculates and applies a steering force towards a target
    // STEER = DESIRED MINUS VELOCITY
    this.seek = function(target) {
        var desired = p5.Vector.sub(target,this.position);  // A vector pointing from the location to the target
        // Normalize desired and scale to maximum speed
        desired.normalize();
        desired.mult(this.maxspeed);
        // Steering = Desired minus Velocity
        var steer = p5.Vector.sub(desired,this.velocity);
        steer.limit(this.maxforce);  // Limit to maximum steering force
        return steer;
    }
    
    this.render = function() {
        noStroke();
        fill(255);
        rect(this.position.x, this.position.y, this.w, this.h);
    }
    
    // Wraparound
    this.borders = function() {
      if (this.position.x < -this.r)  this.position.x = width +this.r;
      if (this.position.y < -this.r)  this.position.y = height+this.r;
      if (this.position.x > width +this.r) this.position.x = -this.r;
      if (this.position.y > height+this.r) this.position.y = -this.r;
    }
    
    // Separation
    // Method checks for nearby boids and steers away
    this.separate = function(boids) {
      var desiredseparation = 12.0;
      var steer = createVector(0,0);
      var count = 0;
      // For every boid in the system, check if it's too close
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
        if ((d > 0) && (d < desiredseparation)) {
          // Calculate vector pointing away from neighbor
          var diff = p5.Vector.sub(this.position,boids[i].position);
          diff.normalize();
          diff.div(d);        // Weight by distance
          steer.add(diff);
          count++;            // Keep track of how many
        }
      }
      // Average -- divide by how many
      if (count > 0) {
        steer.div(count);
      }

      // As long as the vector is greater than 0
      if (steer.mag() > 0) {
        // Implement Reynolds: Steering = Desired - Velocity
        steer.normalize();
        steer.mult(this.maxspeed);
        steer.sub(this.velocity);
        steer.limit(this.maxforce);
      }
      return steer;
    }
    
    // Alignment
    // For every nearby boid in the system, calculate the average velocity
    this.align = function(boids) {
      var neighbordist = 50;
      var sum = createVector(0,0);
      var count = 0;
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        if ((d > 0) && (d < neighbordist)) {
          sum.add(boids[i].velocity);
          count++;
        }
      }
      if (count > 0) {
        sum.div(count);
        sum.normalize();
        sum.mult(this.maxspeed);
        var steer = p5.Vector.sub(sum,this.velocity);
        steer.limit(this.maxforce);
        return steer;
      } else {
        return createVector(0,0);
      }
    }
    
    // Cohesion
    // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
    this.cohesion = function(boids) {
      var neighbordist = 50;
      var sum = createVector(0,0);   // Start with empty vector to accumulate all locations
      var count = 0;
      for (var i = 0; i < boids.length; i++) {
        var d = p5.Vector.dist(this.position,boids[i].position);
        if ((d > 0) && (d < neighbordist)) {
          sum.add(boids[i].position); // Add location
          count++;
        }
      }
      if (count > 0) {
        sum.div(count);
        return this.seek(sum);  // Steer towards the location
      } else {
        return createVector(0,0);
      }
    }
}
            
var cam1 = 60;
var cam2 = 10;

/////WEBSOCKET INFLUENCES:
//
//    //WHEN YOU BREACH THE TAILINGS POND
//    socket.on('breach-out', function(data){
//        if (pondLeak == false) {
//            pondLeak = true;        
//        }
//    });
//
//    //WHEN A BOOK GETS PRINTED
//    socket.on('printed-out', function(data){
//        var r = floor(random(trunks.length));
//        trunks[r].death(r);
//    });
//
//  //UPDATED WEATHER DATA FROM MANILLA EVERY THIRTY SECONDS
//    socket.on('manila-out', function(data) { 
//        console.log(data);
//       //do someting with the "data" variable.
//       //have a look at all the info we have in that JSON feed here: http://openweathermap.org/current#parameter
//
//    });
//
//    //THE CAMERAS
//    socket.on('c2-out', function(data) { 
//        var newCam1 = data[0]; //cam 1 determines tree growth rate
//        newCam1 = (newCam1[0] + newCam1[1] + newCam1[2])/3;
//        newCam1 = 120 * (newCam1/255);
//        newCam1 = 120 - newCam1;
//        cam1 = floor(newCam1);
//        console.log(cam1);
//        
//        newCam2 = data[1];
//        newCam2 = (newCam2[0] + newCam2[1] + newCam2[2])/3;
//        newCam2 = (newCam2-0)/(255-0)*(20-5)+5;
//        cam2 = floor(newCam2);
//        console.log(cam2);
//        //this is just receiving one pixel from each feed, you can change what gets sent from this page:
//
//        // /public/camera1.html
//    });
    </script>
    